//! Setup module for first-time configuration
//!
//! Handles password hashing, .env file creation, and setup state detection.

use bcrypt::{hash, DEFAULT_COST};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::PathBuf;
use tauri::{AppHandle, Manager};

#[derive(Debug, Serialize, Deserialize)]
pub struct SetupConfig {
    pub password: String,
    pub user_name: String,
}

/// Get the app data directory for storing configuration
fn get_data_dir(app: &AppHandle) -> PathBuf {
    // In production, use the directory where the exe is located
    // This matches the Python launcher behavior
    if cfg!(debug_assertions) {
        // Dev mode: use project root
        std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."))
    } else {
        // Production: use exe directory
        std::env::current_exe()
            .ok()
            .and_then(|p| p.parent().map(|p| p.to_path_buf()))
            .unwrap_or_else(|| {
                app.path().app_data_dir()
                    .unwrap_or_else(|_| PathBuf::from("."))
            })
    }
}

/// Check if the .env file exists and has valid configuration
fn is_env_configured(data_dir: &PathBuf) -> bool {
    let env_file = data_dir.join(".env");

    if !env_file.exists() {
        return false;
    }

    let content = match fs::read_to_string(&env_file) {
        Ok(c) => c,
        Err(_) => return false,
    };

    // Check for placeholder values that indicate unconfigured state
    let has_valid_hash = content.contains("API_KEY_HASH=")
        && !content.contains("example_hash")
        && !content.contains("paste_your");
    let has_valid_jwt =
        content.contains("JWT_SECRET=") && !content.contains("your-random-secret");

    has_valid_hash && has_valid_jwt
}

/// Check if setup is needed (called from lib.rs during app setup)
pub fn is_setup_needed(app: &AppHandle) -> bool {
    let data_dir = get_data_dir(app);
    !is_env_configured(&data_dir)
}

/// Tauri command: Check if setup wizard should be shown
#[tauri::command]
pub fn check_setup_needed(app: AppHandle) -> bool {
    is_setup_needed(&app)
}

/// Tauri command: Get the app data directory path
#[tauri::command]
pub fn get_app_data_dir(app: AppHandle) -> String {
    get_data_dir(&app).to_string_lossy().to_string()
}

/// Tauri command: Create the .env file with user configuration
#[tauri::command]
pub fn create_env_file(app: AppHandle, config: SetupConfig) -> Result<String, String> {
    // Hash the password
    let password_hash =
        hash(config.password.as_bytes(), DEFAULT_COST).map_err(|e| format!("Failed to hash password: {}", e))?;

    // Generate JWT secret
    let jwt_secret: String = (0..64)
        .map(|_| {
            let idx = rand::random::<usize>() % 16;
            "0123456789abcdef".chars().nth(idx).unwrap()
        })
        .collect();

    // Create .env content
    let env_content = format!(
        r#"USER_NAME={}
CLAUDE_AGENT_SDK_SKIP_VERSION_CHECK=true

# Authentication (auto-generated by setup wizard)
API_KEY_HASH={}

# JWT Secret (auto-generated)
JWT_SECRET={}

# Set to "true" for debug logging
DEBUG_AGENTS=false
"#,
        config.user_name, password_hash, jwt_secret
    );

    // Write to file
    let data_dir = get_data_dir(&app);
    let env_file = data_dir.join(".env");

    fs::write(&env_file, env_content)
        .map_err(|e| format!("Failed to write .env file: {}", e))?;

    Ok(env_file.to_string_lossy().to_string())
}

// Simple random implementation to avoid additional dependency
mod rand {
    use std::time::{SystemTime, UNIX_EPOCH};
    use std::cell::Cell;

    thread_local! {
        static RNG_STATE: Cell<u64> = Cell::new(
            SystemTime::now()
                .duration_since(UNIX_EPOCH)
                .map(|d| d.as_nanos() as u64)
                .unwrap_or(12345678)
        );
    }

    pub fn random<T: RandomValue>() -> T {
        T::random()
    }

    pub trait RandomValue {
        fn random() -> Self;
    }

    impl RandomValue for usize {
        fn random() -> Self {
            RNG_STATE.with(|state| {
                // Simple xorshift64
                let mut s = state.get();
                s ^= s << 13;
                s ^= s >> 7;
                s ^= s << 17;
                state.set(s);
                s as usize
            })
        }
    }
}
